{"ast":null,"code":"// File: client/src/utils/syncQueue.js\n// Simple offline queue using localStorage (no extra deps).\n// Stores items in 'dms_sync_queue' as JSON array [{ id, type, payload, createdAt }]\n// Provide: enqueue, getQueue, processQueue, startQueueProcessor, flush\n\nconst QUEUE_KEY = 'dms_sync_queue';\nconst PROCESSING_FLAG = 'dms_sync_processing';\nfunction _readQueue() {\n  try {\n    const raw = localStorage.getItem(QUEUE_KEY);\n    return raw ? JSON.parse(raw) : [];\n  } catch (e) {\n    console.error('Read queue failed', e);\n    return [];\n  }\n}\nfunction _writeQueue(arr) {\n  try {\n    localStorage.setItem(QUEUE_KEY, JSON.stringify(arr));\n  } catch (e) {\n    console.error('Write queue failed', e);\n  }\n}\nexport function getQueue() {\n  return _readQueue();\n}\nexport function enqueue(type, payload) {\n  const q = _readQueue();\n  const id = `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;\n  q.push({\n    id,\n    type,\n    payload,\n    createdAt: new Date().toISOString()\n  });\n  _writeQueue(q);\n  // trigger immediate attempt if online\n  if (navigator.onLine) {\n    processQueue().catch(() => {});\n  }\n  return id;\n}\nexport function removeItemById(id) {\n  const q = _readQueue().filter(item => item.id !== id);\n  _writeQueue(q);\n}\nexport async function processQueue() {\n  // avoid concurrent runs\n  if (localStorage.getItem(PROCESSING_FLAG) === '1') return;\n  localStorage.setItem(PROCESSING_FLAG, '1');\n  try {\n    let q = _readQueue();\n    if (!q.length) return;\n    // process FIFO\n    for (const item of [...q]) {\n      try {\n        // choose endpoint by type\n        if (item.type === 'transaction') {\n          // POST to /api/transactions\n          const token = localStorage.getItem('token');\n          const res = await fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:4000'}/api/transactions`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              ...(token ? {\n                Authorization: `Bearer ${token}`\n              } : {})\n            },\n            body: JSON.stringify(item.payload)\n          });\n          if (!res.ok) {\n            // if 401, clear token and abort (force re-login)\n            if (res.status === 401) {\n              localStorage.removeItem('token');\n              localStorage.removeItem('user');\n              // we stop processing further — user must re-login\n              throw new Error('Unauthorized — stop queue processing');\n            }\n            // for other errors (4xx), remove item (to avoid permanent blockage)\n            if (res.status >= 400 && res.status < 500) {\n              console.warn('Dropping bad queued item', item, 'status', res.status);\n              removeItemById(item.id);\n              q = _readQueue();\n              continue;\n            }\n            // for server errors (5xx), stop to retry later\n            throw new Error(`Server error ${res.status}`);\n          }\n          // success\n          removeItemById(item.id);\n          q = _readQueue();\n          continue;\n        } else {\n          console.warn('Unknown queue item type', item.type);\n          removeItemById(item.id);\n          q = _readQueue();\n          continue;\n        }\n      } catch (err) {\n        // network error or other -> stop processing now, will retry on next online event\n        console.warn('Queue processing stopped due to error:', err && err.message ? err.message : err);\n        break;\n      }\n    }\n  } finally {\n    localStorage.removeItem(PROCESSING_FLAG);\n  }\n}\nexport function startQueueProcessor(opts = {}) {\n  // run on load\n  if (navigator.onLine) {\n    processQueue().catch(e => {\n      console.warn('Initial processQueue failed', e);\n    });\n  }\n  // when back online\n  window.addEventListener('online', () => {\n    console.log('Back online — processing queue');\n    processQueue().catch(e => console.warn(e));\n  });\n  // when tab becomes visible again\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'visible' && navigator.onLine) {\n      processQueue().catch(e => console.warn(e));\n    }\n  });\n  // optionally process periodically\n  if (opts.intervalMs && Number(opts.intervalMs) > 0) {\n    setInterval(() => {\n      if (navigator.onLine) processQueue().catch(e => {});\n    }, Number(opts.intervalMs));\n  }\n}\nexport function flush() {\n  _writeQueue([]);\n}","map":{"version":3,"names":["QUEUE_KEY","PROCESSING_FLAG","_readQueue","raw","localStorage","getItem","JSON","parse","e","console","error","_writeQueue","arr","setItem","stringify","getQueue","enqueue","type","payload","q","id","Date","now","Math","random","toString","slice","push","createdAt","toISOString","navigator","onLine","processQueue","catch","removeItemById","filter","item","length","token","res","fetch","process","env","REACT_APP_API_BASE","method","headers","Authorization","body","ok","status","removeItem","Error","warn","err","message","startQueueProcessor","opts","window","addEventListener","log","document","visibilityState","intervalMs","Number","setInterval","flush"],"sources":["E:/Creative/App/dms/client/src/utils/syncQueue.js"],"sourcesContent":["// File: client/src/utils/syncQueue.js\r\n// Simple offline queue using localStorage (no extra deps).\r\n// Stores items in 'dms_sync_queue' as JSON array [{ id, type, payload, createdAt }]\r\n// Provide: enqueue, getQueue, processQueue, startQueueProcessor, flush\r\n\r\nconst QUEUE_KEY = 'dms_sync_queue';\r\nconst PROCESSING_FLAG = 'dms_sync_processing';\r\n\r\nfunction _readQueue() {\r\n  try {\r\n    const raw = localStorage.getItem(QUEUE_KEY);\r\n    return raw ? JSON.parse(raw) : [];\r\n  } catch (e) {\r\n    console.error('Read queue failed', e);\r\n    return [];\r\n  }\r\n}\r\nfunction _writeQueue(arr) {\r\n  try {\r\n    localStorage.setItem(QUEUE_KEY, JSON.stringify(arr));\r\n  } catch (e) {\r\n    console.error('Write queue failed', e);\r\n  }\r\n}\r\n\r\nexport function getQueue() {\r\n  return _readQueue();\r\n}\r\n\r\nexport function enqueue(type, payload) {\r\n  const q = _readQueue();\r\n  const id = `${Date.now()}_${Math.random().toString(36).slice(2,9)}`;\r\n  q.push({ id, type, payload, createdAt: new Date().toISOString() });\r\n  _writeQueue(q);\r\n  // trigger immediate attempt if online\r\n  if (navigator.onLine) {\r\n    processQueue().catch(() => {});\r\n  }\r\n  return id;\r\n}\r\n\r\nexport function removeItemById(id) {\r\n  const q = _readQueue().filter(item => item.id !== id);\r\n  _writeQueue(q);\r\n}\r\n\r\nexport async function processQueue() {\r\n  // avoid concurrent runs\r\n  if (localStorage.getItem(PROCESSING_FLAG) === '1') return;\r\n  localStorage.setItem(PROCESSING_FLAG, '1');\r\n  try {\r\n    let q = _readQueue();\r\n    if (!q.length) return;\r\n    // process FIFO\r\n    for (const item of [...q]) {\r\n      try {\r\n        // choose endpoint by type\r\n        if (item.type === 'transaction') {\r\n          // POST to /api/transactions\r\n          const token = localStorage.getItem('token');\r\n          const res = await fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:4000'}/api/transactions`, {\r\n            method: 'POST',\r\n            headers: {\r\n              'Content-Type': 'application/json',\r\n              ...(token ? { Authorization: `Bearer ${token}` } : {})\r\n            },\r\n            body: JSON.stringify(item.payload)\r\n          });\r\n          if (!res.ok) {\r\n            // if 401, clear token and abort (force re-login)\r\n            if (res.status === 401) {\r\n              localStorage.removeItem('token');\r\n              localStorage.removeItem('user');\r\n              // we stop processing further — user must re-login\r\n              throw new Error('Unauthorized — stop queue processing');\r\n            }\r\n            // for other errors (4xx), remove item (to avoid permanent blockage)\r\n            if (res.status >= 400 && res.status < 500) {\r\n              console.warn('Dropping bad queued item', item, 'status', res.status);\r\n              removeItemById(item.id);\r\n              q = _readQueue();\r\n              continue;\r\n            }\r\n            // for server errors (5xx), stop to retry later\r\n            throw new Error(`Server error ${res.status}`);\r\n          }\r\n          // success\r\n          removeItemById(item.id);\r\n          q = _readQueue();\r\n          continue;\r\n        } else {\r\n          console.warn('Unknown queue item type', item.type);\r\n          removeItemById(item.id);\r\n          q = _readQueue();\r\n          continue;\r\n        }\r\n      } catch (err) {\r\n        // network error or other -> stop processing now, will retry on next online event\r\n        console.warn('Queue processing stopped due to error:', err && err.message ? err.message : err);\r\n        break;\r\n      }\r\n    }\r\n  } finally {\r\n    localStorage.removeItem(PROCESSING_FLAG);\r\n  }\r\n}\r\n\r\nexport function startQueueProcessor(opts = {}) {\r\n  // run on load\r\n  if (navigator.onLine) {\r\n    processQueue().catch((e) => { console.warn('Initial processQueue failed', e); });\r\n  }\r\n  // when back online\r\n  window.addEventListener('online', () => {\r\n    console.log('Back online — processing queue');\r\n    processQueue().catch(e => console.warn(e));\r\n  });\r\n  // when tab becomes visible again\r\n  document.addEventListener('visibilitychange', () => {\r\n    if (document.visibilityState === 'visible' && navigator.onLine) {\r\n      processQueue().catch(e => console.warn(e));\r\n    }\r\n  });\r\n  // optionally process periodically\r\n  if (opts.intervalMs && Number(opts.intervalMs) > 0) {\r\n    setInterval(() => {\r\n      if (navigator.onLine) processQueue().catch(e => {});\r\n    }, Number(opts.intervalMs));\r\n  }\r\n}\r\n\r\nexport function flush() {\r\n  _writeQueue([]);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}