{"ast":null,"code":"// File: dms/client/src/utils/syncQueue.js\n// REPLACE previous localforage-only version.\n// It keeps localforage queue and ALSO writes a SW-readable copy (via idb sw_requests)\n// It tries to upload to server; if server returns 5xx or network fails, it attempts to POST to /api/pending\nimport localforage from 'localforage';\nimport { addSwRequest, deleteSwRequest } from './sw-idb';\nconst QUEUE_KEY = 'dms_sync_queue_v2';\nconst PROCESSING_FLAG = 'dms_sync_processing_v2';\nlocalforage.config({\n  name: 'dms',\n  storeName: 'sync_queue'\n});\nasync function _readQueue() {\n  const q = await localforage.getItem(QUEUE_KEY);\n  return Array.isArray(q) ? q : [];\n}\nasync function _writeQueue(arr) {\n  await localforage.setItem(QUEUE_KEY, arr || []);\n}\nexport async function getQueue() {\n  return await _readQueue();\n}\nexport async function enqueue(type, payload) {\n  const q = await _readQueue();\n  const id = `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;\n  const item = {\n    id,\n    type,\n    payload,\n    createdAt: new Date().toISOString()\n  };\n  q.push(item);\n  await _writeQueue(q);\n  // also write SW copy for replay\n  try {\n    await addSwRequest(item);\n  } catch (e) {\n    console.warn('addSwRequest failed', e);\n  }\n  // try to register background sync\n  if ('serviceWorker' in navigator && 'SyncManager' in window) {\n    try {\n      const reg = await navigator.serviceWorker.ready;\n      await reg.sync.register('dms-sync');\n    } catch (e) {\n      console.warn('sync register failed', e);\n    }\n  }\n  if (navigator.onLine) processQueue().catch(() => {});\n  return id;\n}\nexport async function removeItemById(id) {\n  // remove from both localforage queue and SW idb store\n  const q = await _readQueue();\n  const filtered = q.filter(it => it.id !== id);\n  await _writeQueue(filtered);\n  try {\n    await deleteSwRequest(id);\n  } catch (e) {/* ignore */}\n}\nasync function _isProcessing() {\n  return !!(await localforage.getItem(PROCESSING_FLAG));\n}\nasync function _setProcessing(val) {\n  if (val) await localforage.setItem(PROCESSING_FLAG, true);else await localforage.removeItem(PROCESSING_FLAG);\n}\nexport async function processQueue() {\n  if (await _isProcessing()) return;\n  await _setProcessing(true);\n  try {\n    let q = await _readQueue();\n    if (!q.length) return;\n    for (const item of [...q]) {\n      try {\n        if (item.type === 'transaction') {\n          const token = localStorage.getItem('token');\n          const res = await fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:4000'}/api/transactions`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              ...(token ? {\n                Authorization: `Bearer ${token}`\n              } : {})\n            },\n            body: JSON.stringify(item.payload)\n          });\n          if (!res.ok) {\n            // If client is authorized and server returns 5xx (server error), push to server-side pending queue\n            if (res.status >= 500) {\n              try {\n                const uploadRes = await fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:4000'}/api/pending`, {\n                  method: 'POST',\n                  headers: {\n                    'Content-Type': 'application/json',\n                    ...(token ? {\n                      Authorization: `Bearer ${token}`\n                    } : {})\n                  },\n                  body: JSON.stringify({\n                    type: item.type,\n                    payload: item.payload\n                  })\n                });\n                if (uploadRes.ok) {\n                  // remove local queued item and SW stored request\n                  await removeItemById(item.id);\n                  q = await _readQueue();\n                  continue;\n                }\n              } catch (e) {/* can't reach server to create pending */}\n            }\n            // 401 -> wipe auth and stop processing\n            if (res.status === 401) {\n              localStorage.removeItem('token');\n              localStorage.removeItem('user');\n              throw new Error('Unauthorized');\n            }\n            // 4xx invalid -> drop it\n            if (res.status >= 400 && res.status < 500) {\n              await removeItemById(item.id);\n              q = await _readQueue();\n              continue;\n            }\n            throw new Error('Server error ' + res.status);\n          }\n          // success: remove both stores (localforage & sw idb)\n          await removeItemById(item.id);\n          q = await _readQueue();\n          // also remove SW copy to avoid double send\n          try {\n            await deleteSwRequest(item.id);\n          } catch (e) {/* ignore */}\n          continue;\n        } else {\n          // unknown type -> remove\n          await removeItemById(item.id);\n          q = await _readQueue();\n          continue;\n        }\n      } catch (err) {\n        console.warn('Queue processing stopped:', err && err.message ? err.message : err);\n        break;\n      }\n    }\n  } finally {\n    await _setProcessing(false);\n  }\n}\nexport function startQueueProcessor(opts = {}) {\n  if (navigator.onLine) processQueue().catch(() => {});\n  window.addEventListener('online', () => processQueue().catch(() => {}));\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'visible' && navigator.onLine) processQueue().catch(() => {});\n  });\n  if (opts.intervalMs && Number(opts.intervalMs) > 0) setInterval(() => {\n    if (navigator.onLine) processQueue().catch(() => {});\n  }, Number(opts.intervalMs));\n}\nexport async function flush() {\n  await _writeQueue([]);\n  try {\n    const db = await (await import('./sw-idb')).getDb();\n    await db.clear('sw_requests');\n  } catch (e) {/* ignore */}\n}","map":{"version":3,"names":["localforage","addSwRequest","deleteSwRequest","QUEUE_KEY","PROCESSING_FLAG","config","name","storeName","_readQueue","q","getItem","Array","isArray","_writeQueue","arr","setItem","getQueue","enqueue","type","payload","id","Date","now","Math","random","toString","slice","item","createdAt","toISOString","push","e","console","warn","navigator","window","reg","serviceWorker","ready","sync","register","onLine","processQueue","catch","removeItemById","filtered","filter","it","_isProcessing","_setProcessing","val","removeItem","length","token","localStorage","res","fetch","process","env","REACT_APP_API_BASE","method","headers","Authorization","body","JSON","stringify","ok","status","uploadRes","Error","err","message","startQueueProcessor","opts","addEventListener","document","visibilityState","intervalMs","Number","setInterval","flush","db","getDb","clear"],"sources":["E:/Creative/App/dms/client/src/utils/syncQueue.js"],"sourcesContent":["// File: dms/client/src/utils/syncQueue.js\r\n// REPLACE previous localforage-only version.\r\n// It keeps localforage queue and ALSO writes a SW-readable copy (via idb sw_requests)\r\n// It tries to upload to server; if server returns 5xx or network fails, it attempts to POST to /api/pending\r\nimport localforage from 'localforage';\r\nimport { addSwRequest, deleteSwRequest } from './sw-idb';\r\n\r\nconst QUEUE_KEY = 'dms_sync_queue_v2';\r\nconst PROCESSING_FLAG = 'dms_sync_processing_v2';\r\nlocalforage.config({ name: 'dms', storeName: 'sync_queue' });\r\n\r\nasync function _readQueue(){ const q = await localforage.getItem(QUEUE_KEY); return Array.isArray(q) ? q : []; }\r\nasync function _writeQueue(arr){ await localforage.setItem(QUEUE_KEY, arr || []); }\r\n\r\nexport async function getQueue(){ return await _readQueue(); }\r\n\r\nexport async function enqueue(type, payload){\r\n  const q = await _readQueue();\r\n  const id = `${Date.now()}_${Math.random().toString(36).slice(2,9)}`;\r\n  const item = { id, type, payload, createdAt: new Date().toISOString() };\r\n  q.push(item);\r\n  await _writeQueue(q);\r\n  // also write SW copy for replay\r\n  try { await addSwRequest(item); } catch(e){ console.warn('addSwRequest failed', e); }\r\n  // try to register background sync\r\n  if ('serviceWorker' in navigator && 'SyncManager' in window) {\r\n    try { const reg = await navigator.serviceWorker.ready; await reg.sync.register('dms-sync'); } catch(e){ console.warn('sync register failed', e); }\r\n  }\r\n  if (navigator.onLine) processQueue().catch(()=>{});\r\n  return id;\r\n}\r\n\r\nexport async function removeItemById(id){\r\n  // remove from both localforage queue and SW idb store\r\n  const q = await _readQueue();\r\n  const filtered = q.filter(it => it.id !== id);\r\n  await _writeQueue(filtered);\r\n  try { await deleteSwRequest(id); } catch(e){ /* ignore */ }\r\n}\r\n\r\nasync function _isProcessing(){ return !!(await localforage.getItem(PROCESSING_FLAG)); }\r\nasync function _setProcessing(val){ if (val) await localforage.setItem(PROCESSING_FLAG, true); else await localforage.removeItem(PROCESSING_FLAG); }\r\n\r\nexport async function processQueue(){\r\n  if (await _isProcessing()) return;\r\n  await _setProcessing(true);\r\n  try {\r\n    let q = await _readQueue();\r\n    if (!q.length) return;\r\n    for (const item of [...q]) {\r\n      try {\r\n        if (item.type === 'transaction') {\r\n          const token = localStorage.getItem('token');\r\n          const res = await fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:4000'}/api/transactions`, {\r\n            method: 'POST',\r\n            headers: { 'Content-Type':'application/json', ...(token ? { Authorization: `Bearer ${token}` } : {}) },\r\n            body: JSON.stringify(item.payload)\r\n          });\r\n          if (!res.ok) {\r\n            // If client is authorized and server returns 5xx (server error), push to server-side pending queue\r\n            if (res.status >= 500) {\r\n              try {\r\n                const uploadRes = await fetch(`${process.env.REACT_APP_API_BASE || 'http://localhost:4000'}/api/pending`, {\r\n                  method: 'POST',\r\n                  headers: { 'Content-Type':'application/json', ...(token ? { Authorization: `Bearer ${token}` } : {}) },\r\n                  body: JSON.stringify({ type: item.type, payload: item.payload })\r\n                });\r\n                if (uploadRes.ok) {\r\n                  // remove local queued item and SW stored request\r\n                  await removeItemById(item.id);\r\n                  q = await _readQueue();\r\n                  continue;\r\n                }\r\n              } catch (e) { /* can't reach server to create pending */ }\r\n            }\r\n            // 401 -> wipe auth and stop processing\r\n            if (res.status === 401) { localStorage.removeItem('token'); localStorage.removeItem('user'); throw new Error('Unauthorized'); }\r\n            // 4xx invalid -> drop it\r\n            if (res.status >= 400 && res.status < 500) {\r\n              await removeItemById(item.id);\r\n              q = await _readQueue();\r\n              continue;\r\n            }\r\n            throw new Error('Server error ' + res.status);\r\n          }\r\n          // success: remove both stores (localforage & sw idb)\r\n          await removeItemById(item.id);\r\n          q = await _readQueue();\r\n          // also remove SW copy to avoid double send\r\n          try { await deleteSwRequest(item.id); } catch(e){ /* ignore */ }\r\n          continue;\r\n        } else {\r\n          // unknown type -> remove\r\n          await removeItemById(item.id);\r\n          q = await _readQueue();\r\n          continue;\r\n        }\r\n      } catch (err) {\r\n        console.warn('Queue processing stopped:', err && err.message ? err.message : err);\r\n        break;\r\n      }\r\n    }\r\n  } finally {\r\n    await _setProcessing(false);\r\n  }\r\n}\r\n\r\nexport function startQueueProcessor(opts = {}) {\r\n  if (navigator.onLine) processQueue().catch(()=>{});\r\n  window.addEventListener('online', () => processQueue().catch(()=>{}));\r\n  document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && navigator.onLine) processQueue().catch(()=>{}); });\r\n  if (opts.intervalMs && Number(opts.intervalMs) > 0) setInterval(() => { if (navigator.onLine) processQueue().catch(()=>{}); }, Number(opts.intervalMs));\r\n}\r\n\r\nexport async function flush() { await _writeQueue([]); try { const db = await (await import('./sw-idb')).getDb(); await db.clear('sw_requests'); } catch(e){ /* ignore */ } }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}