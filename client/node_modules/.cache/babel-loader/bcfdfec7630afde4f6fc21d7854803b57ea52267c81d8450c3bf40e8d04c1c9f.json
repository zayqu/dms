{"ast":null,"code":"const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(this.request);\n    };\n  }\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nconst unwrap = value => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking,\n  terminated\n} = {}) {\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event.newVersion, event));\n  }\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) {\n      db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event));\n  }\n  return wrap(request).then(() => undefined);\n}\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  const method = async function (storeName, ...args) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    if (useIndex) target = target.index(args.shift());\n    // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n  get(target, prop) {\n    if (!advanceMethodProps.includes(prop)) return target[prop];\n    let cachedFunc = methodMap[prop];\n    if (!cachedFunc) {\n      cachedFunc = methodMap[prop] = function (...args) {\n        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n      };\n    }\n    return cachedFunc;\n  }\n};\nasync function* iterate(...args) {\n  // tslint:disable-next-line:no-this-assignment\n  let cursor = this;\n  if (!(cursor instanceof IDBCursor)) {\n    cursor = await cursor.openCursor(...args);\n  }\n  if (!cursor) return;\n  cursor = cursor;\n  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n  // Map this double-proxy back to the original, so other cursor methods work.\n  reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n  while (cursor) {\n    yield proxiedCursor;\n    // If one of the advancing methods was not called, call continue().\n    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n    advanceResults.delete(proxiedCursor);\n  }\n}\nfunction isIteratorProp(target, prop) {\n  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore]);\n}\nreplaceTraps(oldTraps => ({\n  ...oldTraps,\n  get(target, prop, receiver) {\n    if (isIteratorProp(target, prop)) return iterate;\n    return oldTraps.get(target, prop, receiver);\n  },\n  has(target, prop) {\n    return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n  }\n}));\nexport { deleteDB, openDB, unwrap, wrap };","map":{"version":3,"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","set","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","value","replaceTraps","callback","wrapFunction","func","includes","args","apply","unwrap","transformCachableValue","Proxy","IDBRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","transaction","then","db","catch","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","store","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","Symbol","asyncIterator"],"sources":["E:/Creative/App/dms/client/node_modules/idb/build/index.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}